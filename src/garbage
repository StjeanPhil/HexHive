



    const availableQueen = (grid, coord, isOddRowOffset, bugCounter) => {
        // anybufferHex touching the queen
        var tempGrid = grid
        const row = coord[0]
        const col = coord[1]

        if (col > 0 && tempGrid[row][col - 1].isBufferHex) { tempGrid[row][col - 1].isAvailable = true }
        if (col < (tempGrid[row].length - 1) && tempGrid[row][col + 1].isBufferHex) { tempGrid[row][col + 1].isAvailable = true }
        if (row > 0 && tempGrid[row - 1][col].isBufferHex) { tempGrid[row - 1][col].isAvailable = true }
        if (row < (tempGrid.length - 1) && tempGrid[row + 1][col].isBufferHex) { tempGrid[row + 1][col].isAvailable = true }

        if (((row % 2) == 0 && !isOddRowOffset) || ((row % 2) != 0 && isOddRowOffset)) {
            if (col > 0 && row > 0 && tempGrid[row - 1][col - 1] && tempGrid[row - 1][col - 1].isBufferHex) { tempGrid[row - 1][col - 1].isAvailable = true }
            if (col > 0 && row < (tempGrid.length - 1) && tempGrid[row + 1][col - 1] && tempGrid[row + 1][col - 1].isBufferHex) { tempGrid[row + 1][col - 1].isAvailable = true }
        }
        if (((row % 2) == 1 && !isOddRowOffset) || ((row % 2) == 0 && isOddRowOffset)) {
            if (col < (tempGrid[row].length - 1) && row > 0 && tempGrid[row - 1][col + 1] && tempGrid[row - 1][col + 1].isBufferHex) { tempGrid[row - 1][col + 1].isAvailable = true }
            if (col < (tempGrid[row].length - 1) && row < (tempGrid.length - 1) && tempGrid[row + 1][col + 1] && tempGrid[row + 1][col + 1].isBufferHex) { tempGrid[row + 1][col + 1].isAvailable = true }
        }
        return tempGrid
    }
    const availableSpider = (grid, coord, count, usedCoord, isOddRowOffset, bugCounter) => {
        //exactly 3 hex from the spider, cant go up bug
        //toggle avalability when counter hits zero
        var tempGrid = grid
        const row = coord[0]
        const col = coord[1]
        //recursive ending
        if (count === 0) {
            tempGrid[row][col].isAvailable = hiveIntegrityCheck(tempGrid, usedCoord[0], coord, isOddRowOffset, bugCounter)
            return tempGrid
        }
        count -= 1
        usedCoord += coord

        if (col > 0 && tempGrid[row][col - 1] && tempGrid[row][col - 1].isBufferHex) {
            if (!usedCoord.includes([row, col - 1])) {
                tempGrid = availableSpider(tempGrid, [row, col - 1], count, usedCoord, isOddRowOffset)
            }

        }
        if (col < (tempGrid[row].length - 1) && tempGrid[row][col + 1] && tempGrid[row][col + 1].isBufferHex) {
            if (!usedCoord.includes([row, col + 1])) {
                tempGrid = availableSpider(tempGrid, [row, col + 1], count, usedCoord, isOddRowOffset)
            }
        }
        if (row > 0 && tempGrid[row - 1][col] && tempGrid[row - 1][col].isBufferHex) {
            if (!usedCoord.includes([row - 1, col])) {
                tempGrid = availableSpider(tempGrid, [row - 1, col], count, usedCoord, isOddRowOffset)
            }
        }
        if (row < (tempGrid.length - 1) && tempGrid[row + 1][col] && tempGrid[row + 1][col].isBufferHex) {
            if (!usedCoord.includes([row + 1, col])) {
                tempGrid = availableSpider(tempGrid, [row + 1, col], count, usedCoord, isOddRowOffset)
            }
        }

        if (((row % 2) == 0 && !isOddRowOffset) || ((row % 2) != 0 && isOddRowOffset)) {
            if (col > 0 && row > 0 && tempGrid[row - 1][col - 1] && tempGrid[row - 1][col - 1].isBufferHex) {
                if (!usedCoord.includes([row - 1, col - 1])) {
                    tempGrid = availableSpider(tempGrid, [row - 1, col - 1], count, usedCoord, isOddRowOffset)
                }
            }
            if (col > 0 && row < (tempGrid.length - 1) && tempGrid[row + 1][col - 1] && tempGrid[row + 1][col - 1].isBufferHex) {
                if (!usedCoord.includes([row + 1, col - 1])) {
                    tempGrid = availableSpider(tempGrid, [row + 1, col - 1], count, usedCoord, isOddRowOffset)
                }
            }
        }
        if (((row % 2) == 1 && !isOddRowOffset) || ((row % 2) == 0 && isOddRowOffset)) {
            if (col < (tempGrid[row].length - 1) && row > 0 && tempGrid[row - 1][col + 1] && tempGrid[row - 1][col + 1].isBufferHex) {
                if (!usedCoord.includes([row - 1, col + 1])) {
                    tempGrid = availableSpider(tempGrid, [row - 1, col + 1], count, usedCoord, isOddRowOffset)
                }
            }
            if (col < (tempGrid[row].length - 1) && row < (tempGrid.length - 1) && tempGrid[row + 1][col + 1] && tempGrid[row + 1][col + 1].isBufferHex) {
                if (!usedCoord.includes([row + 1, col + 1])) {
                    tempGrid = availableSpider(tempGrid, [row + 1, col + 1], count, usedCoord, isOddRowOffset)
                }
            }
        }
        return tempGrid

    }
    //it no works
    const availableGrasshop = (grid, coord, isOddRowOffset, bugCounter) => {

        var tempGrid = grid
        const row = coord[0]
        const col = coord[1]

        if (col > 0 && !tempGrid[row][col - 1].isBufferHex) { tempGrid = grasshopJump(tempGrid, [row, col - 1], [0, -1], isOddRowOffset) }
        if (col < (tempGrid[row].length - 1) && !tempGrid[row][col + 1].isBufferHex) { tempGrid = grasshopJump(tempGrid, [row, col + 1], [0, 1], isOddRowOffset) }

        //offset 
        if (((row % 2) == 0 && !isOddRowOffset) || ((row % 2) !== 0 && isOddRowOffset)) {
            if (row > 0 && !tempGrid[row - 1][col].isBufferHex) { tempGrid = grasshopJump(tempGrid, [row - 1, col], [-1, 1], isOddRowOffset) }
            if (row < (tempGrid.length - 1) && !tempGrid[row + 1][col].isBufferHex) { tempGrid = grasshopJump(tempGrid, [row + 1, col], [1, 1], isOddRowOffset) }
            if (col > 0 && row > 0 && tempGrid[row - 1][col - 1] && !tempGrid[row - 1][col - 1].isBufferHex) { tempGrid = grasshopJump(tempGrid, [row - 1, col - 1], [-1, -1], isOddRowOffset) }
            if (col > 0 && row < (tempGrid.length - 1) && tempGrid[row + 1][col - 1] && !tempGrid[row + 1][col - 1].isBufferHex) { tempGrid = grasshopJump(tempGrid, [row + 1, col - 1], [1, -1], isOddRowOffset) }
        }
        //not offset
        if (((row % 2) !== 0 && !isOddRowOffset) || ((row % 2) == 0 && isOddRowOffset)) {
            if (row > 0 && !tempGrid[row - 1][col].isBufferHex) { tempGrid = grasshopJump(tempGrid, [row - 1, col], [-1, -1], isOddRowOffset) }
            if (row < (tempGrid.length - 1) && !tempGrid[row + 1][col].isBufferHex) { tempGrid = grasshopJump(tempGrid, [row + 1, col], [1, -1], isOddRowOffset) }
            if (col < (tempGrid[row].length - 1) && row > 0 && tempGrid[row - 1][col + 1] && !tempGrid[row - 1][col + 1].isBufferHex) { tempGrid = grasshopJump(tempGrid, [row - 1, col + 1], [-1, 1], isOddRowOffset) }
            if (col < (tempGrid[row].length - 1) && row < (tempGrid.length - 1) && tempGrid[row + 1][col + 1] && !tempGrid[row + 1][col + 1].isBufferHex) { tempGrid = grasshopJump(tempGrid, [row + 1, col + 1], [1, 1], isOddRowOffset) }
        }
        return tempGrid

    }
    const grasshopJump = (grid, coord, direction, isOddRowOffset, bugCounter) => {
        var row = coord[0] + direction[0] // row updates everytime
        var col = coord[1]
        var tempGrid = grid
        //if row is stable, col updates everytime
        if (direction[0] === 0) { col = (col === '' ? 1 : col + direction[1]) }
        if (direction[0] !== 0) {
            //if its an offset row(odd row and odd offset OR  even row and not odd offset)
            //not offset
            if (((row % 2) === 0 && isOddRowOffset) || ((row % 2) !== 0 && !isOddRowOffset)) {
                if (direction[1] < 0) {
                    col = (col === '' ? 1 : col + direction[1])
                }
            }
            //offset
            if (((row % 2) != 0 && isOddRowOffset) || ((row % 2) === 0 && !isOddRowOffset)) {
                if (direction[1] > 0) {
                    col = (col === '' ? 1 : col + direction[1])
                }
            }
        }
        if (tempGrid[row][col].isBufferHex) {
            tempGrid[row][col].isAvailable = true
            return tempGrid
        }
        tempGrid = grasshopJump(tempGrid, [row, col], direction, isOddRowOffset)
        return tempGrid
    }
    const availableBeetle = (grid, coord, isOddRowOffset, bugCounter) => {
        var tempGrid = grid
        const row = coord[0]
        const col = coord[1]

        if (col > 0) {
            tempGrid[row][col - 1].isAvailable = hiveIntegrityCheck(grid, coord, [row, col - 1], isOddRowOffset, bugCounter)
            //tempGrid[row][col - 1].isAvailable = true 
        }
        if (col < (tempGrid[row].length - 1)) {
            tempGrid[row][col + 1].isAvailable = hiveIntegrityCheck(grid, coord, [row, col + 1], isOddRowOffset, bugCounter)
            // tempGrid[row][col + 1].isAvailable = true
        }
        if (row > 0) {
            tempGrid[row - 1][col].isAvailable = hiveIntegrityCheck(grid, coord, [row - 1, col], isOddRowOffset, bugCounter)
            // tempGrid[row - 1][col].isAvailable = true
        }
        if (row < (tempGrid.length - 1)) {
            tempGrid[row + 1][col].isAvailable = hiveIntegrityCheck(grid, coord, [row + 1, col], isOddRowOffset, bugCounter)
            // tempGrid[row + 1][col].isAvailable = true 
        }

        if (((row % 2) == 0 && !isOddRowOffset) || ((row % 2) != 0 && isOddRowOffset)) {
            if (col > 0 && row > 0 && tempGrid[row - 1][col - 1]) {
                tempGrid[row - 1][col - 1].isAvailable = hiveIntegrityCheck(grid, coord, [row - 1, col - 1], isOddRowOffset, bugCounter)
                // tempGrid[row - 1][col - 1].isAvailable = true
            }
            if (col > 0 && row < (tempGrid.length - 1) && tempGrid[row + 1][col - 1]) {
                tempGrid[row + 1][col - 1].isAvailable = hiveIntegrityCheck(grid, coord, [row + 1, col - 1], isOddRowOffset, bugCounter)
                //tempGrid[row + 1][col - 1].isAvailable = true
            }
        }
        if (((row % 2) == 1 && !isOddRowOffset) || ((row % 2) == 0 && isOddRowOffset)) {
            if (col < (tempGrid[row].length - 1) && row > 0 && tempGrid[row - 1][col + 1]) {
                tempGrid[row - 1][col + 1].isAvailable = hiveIntegrityCheck(grid, coord, [row - 1, col + 1], isOddRowOffset, bugCounter)
                //tempGrid[row - 1][col + 1].isAvailable = true
            }
            if (col < (tempGrid[row].length - 1) && row < (tempGrid.length - 1) && tempGrid[row + 1][col + 1]) {
                tempGrid[row + 1][col + 1].isAvailable = hiveIntegrityCheck(grid, coord, [row + 1, col + 1], isOddRowOffset, bugCounter)
                //tempGrid[row + 1][col + 1].isAvailable = true
            }
        }
        return tempGrid
    }
    const availableAnt = (grid, coord, usedCoord, startNodeCoord, isOddRowOffset, bugCounter) => {
        var tempGrid = grid
        const row = coord[0]
        const col = coord[1]
        //recursive ending
        if (usedCoord.includes(coord)) { return tempGrid }
        usedCoord += coord

        tempGrid[row][col].isAvailable = hiveIntegrityCheck(tempGrid, startNodeCoord, coord, isOddRowOffset, bugCounter)

        if (col > 0 && tempGrid[row][col - 1] && tempGrid[row][col - 1].isBufferHex) {
            tempGrid = availableAnt(tempGrid, [row, col - 1], usedCoord, startNodeCoord, isOddRowOffset)
        }
        if (col < (tempGrid[0].length - 1) && tempGrid[row][col + 1] && tempGrid[row][col + 1].isBufferHex) {
            tempGrid = availableAnt(tempGrid, [row, col + 1], usedCoord, startNodeCoord, isOddRowOffset)
        }
        if (row > 0 && tempGrid[row - 1][col] && tempGrid[row - 1][col].isBufferHex) {
            tempGrid = availableAnt(tempGrid, [row - 1, col], usedCoord, startNodeCoord, isOddRowOffset)
        }
        if (row < (tempGrid.length - 1) && tempGrid[row + 1][col] && tempGrid[row + 1][col].isBufferHex) {
            tempGrid = availableAnt(tempGrid, [row + 1, col], usedCoord, startNodeCoord, isOddRowOffset)
        }

        if (((row % 2) == 0 && !isOddRowOffset) || ((row % 2) != 0 && isOddRowOffset)) {
            if (col > 0 && row > 0 && tempGrid[row - 1][col - 1] && tempGrid[row - 1][col - 1].isBufferHex) {
                tempGrid = availableAnt(tempGrid, [row - 1, col - 1], usedCoord, startNodeCoord, isOddRowOffset)
            }
            if (col > 0 && row < (tempGrid.length - 1) && tempGrid[row + 1][col - 1] && tempGrid[row + 1][col - 1].isBufferHex) {
                tempGrid = availableAnt(tempGrid, [row + 1, col - 1], usedCoord, startNodeCoord, isOddRowOffset)
            }
        }
        if (((row % 2) == 1 && !isOddRowOffset) || ((row % 2) == 0 && isOddRowOffset)) {
            if (col < (tempGrid[0].length - 1) && row > 0 && tempGrid[row - 1][col + 1] && tempGrid[row - 1][col + 1].isBufferHex) {
                tempGrid = availableAnt(tempGrid, [row - 1, col + 1], usedCoord, startNodeCoord, isOddRowOffset)
            }
            if (col < (tempGrid[0].length - 1) && row < (tempGrid.length - 1) && tempGrid[row + 1][col + 1] && tempGrid[row + 1][col + 1].isBufferHex) {
                tempGrid = availableAnt(tempGrid, [row + 1, col + 1], usedCoord, startNodeCoord, isOddRowOffset)
            }
        }

        return tempGrid
    }
    //works for now but still WIP -> need team recon
    const availableForPlacing = (grid, player, isOddRowOffset, bugCounter) => {
        //need to check its only touching its teammates
        var tempGrid = grid
        for (var i = 0; i < tempGrid.length; i++) {
            for (var j = 0; j < tempGrid[0].length; j++) {
                if (tempGrid[i][j] && tempGrid[i][j].isBufferHex) {
                    //CHECK IF ALL TOUCHING NODE ARE OWNED BY CURRENTPLAYER
                    tempGrid[i][j].isAvailable = true
                }
            }
        }
        return tempGrid
    }
    //returns true of false
    const hiveIntegrityCheck = (grid, startNodeCoord, endNodeCoord, isOddRowOffset, bugCounter) => {
        //return true

        //clone and not reference the grid
        let testGrid = JSON.parse(JSON.stringify(grid));

        testGrid[endNodeCoord[0]][endNodeCoord[1]].content.unshift(testGrid[startNodeCoord[0]][startNodeCoord[1]].content.shift())

        console.log(testGrid[startNodeCoord[0]][startNodeCoord[1]].content)
        console.log(testGrid[endNodeCoord[0]][endNodeCoord[1]].content)

        var connectedBugsCount = countConnectedBugs(testGrid, endNodeCoord, [], isOddRowOffset)

        if (connectedBugsCount === bugCounter) { return true }
        return false
    }
    //return a count of how many bugs are connected to this one
    const countConnectedBugs = (tempGrid, coord, count, countedCoords, isOddRowOffset) => {

        count = Number(count) + tempGrid[coord[0]][coord[1]].content.length

        countedCoords += coord

        const row = coord[0]
        const col = coord[1]

        if (col > 0 && tempGrid[row][col - 1] && !tempGrid[row][col - 1].isBufferHex && !countedCoords.includes([row, col - 1])) { count += countConnectedBugs(tempGrid, [row, col - 1], count, countedCoords, isOddRowOffset) }
        if (col < (tempGrid[row].length - 1) && tempGrid[row][col + 1] && !tempGrid[row][col + 1].isBufferHex && !countedCoords.includes([row, col + 1])) { count += countConnectedBugs(tempGrid, [row, col + 1], count, countedCoords, isOddRowOffset) }
        if (row > 0 && tempGrid[row - 1][col] && !tempGrid[row - 1][col].isBufferHex && !countedCoords.includes([row - 1, col])) { count += countConnectedBugs(tempGrid, [row - 1, col], count, countedCoords, isOddRowOffset) }
        if (row < (tempGrid.length - 1) && tempGrid[row + 1][col] && !tempGrid[row + 1][col].isBufferHex && !countedCoords.includes([row + 1, col])) { count += countConnectedBugs(tempGrid, [row + 1, col], count, countedCoords, isOddRowOffset) }

        if (((row % 2) == 0 && !isOddRowOffset) || ((row % 2) != 0 && isOddRowOffset)) {
            if (col > 0 && row > 0 && tempGrid[row - 1][col - 1] && !tempGrid[row - 1][col - 1].isBufferHex && !countedCoords.includes([row - 1, col - 1])) { count += countConnectedBugs(tempGrid, [row - 1, col - 1], count, countedCoords, isOddRowOffset) }
            if (col > 0 && row < (tempGrid.length - 1) && tempGrid[row + 1][col - 1] && !tempGrid[row + 1][col - 1].isBufferHex && !countedCoords.includes([row + 1, col - 1])) { count += countConnectedBugs(tempGrid, [row + 1, col - 1], count, countedCoords, isOddRowOffset) }
        }
        if (((row % 2) == 1 && !isOddRowOffset) || ((row % 2) == 0 && isOddRowOffset)) {
            if (col < (tempGrid[row].length - 1) && row > 0 && tempGrid[row - 1][col + 1] && !tempGrid[row - 1][col + 1].isBufferHex && !countedCoords.includes([row - 1, col + 1])) { count += countConnectedBugs(tempGrid, [row - 1, col + 1], count, countedCoords, isOddRowOffset) }
            if (col < (tempGrid[row].length - 1) && row < (tempGrid.length - 1) && tempGrid[row + 1][col + 1] && !tempGrid[row + 1][col + 1].isBufferHex && !countedCoords.includes([row + 1, col + 1])) { count += countConnectedBugs(tempGrid, [row + 1, col + 1], count, countedCoords, isOddRowOffset) }
        }
        //console.log('count is now at: ' + count)
        return count

    }
    //wip
    const showAvailableNodes = (tempGrid, coord, location, player, isOddRowOffset, bugCounter) => {
        if (location === 'hand') {
            //Show avalability of new hex for players [currentplayer]
            //  any bufferHex touching only current player's hexs
            tempGrid = availableForPlacing(tempGrid, player, isOddRowOffset)

        }
        if (location === 'hive') {
            var bug = tempGrid[coord[0]][coord[1]].content[0]

            //console.log(bug)

            if (bug.name === 'Queen') {

                console.log('queen procedure')
                tempGrid = availableQueen(tempGrid, coord, isOddRowOffset, bugCounter)
            }
            if (bug.name === 'Spider') {
                console.log('spider procedure')
                const count = 3
                const usedCoord = []
                tempGrid = availableSpider(tempGrid, coord, count, usedCoord, isOddRowOffset, bugCounter)
            }
            if (bug.name === 'Beetle') {
                console.log('beetle procedure')
                tempGrid = availableBeetle(tempGrid, coord, isOddRowOffset, bugCounter)
            }
            if (bug.name === 'Grasshop') {

                console.log('Grasshop procedure')
                tempGrid = availableGrasshop(tempGrid, coord, isOddRowOffset, bugCounter)
            }
            if (bug.name === 'Ant') {

                console.log('ant procedure')
                const usedCoord = []
                const startNodeCoord = coord


                tempGrid = availableAnt(tempGrid, coord, usedCoord, startNodeCoord, isOddRowOffset, bugCounter)
            }
        }
        return tempGrid

    }
    //Remove the Available status on all the nodes of the hive
    const hideAvailableNodes = (grid) => {


        for (var i = 0; i < grid.length; i++) {
            for (var j = 0; j < grid[0].length; j++) {
                if (grid[i][j]) {
                    grid[i][j].isAvailable = false
                }
            }
        }
        return grid
    }


    //grid maintenance


    const gridMaintenance = (grid, lastPlayedNode, isOddRowOffset) => {

        var { tempGrid, tempIsOddRowOffset } = expandGrid(grid, lastPlayedNode, isOddRowOffset)
        tempGrid = removeUnconnectedNodes(tempGrid, tempIsOddRowOffset)
        var { Grid, IsOddRowOffset } = keepGridSmall(tempGrid, tempIsOddRowOffset)
        return { Grid, IsOddRowOffset }
    }
    //Add all the hex that border the hex we just put on the coord passed in porp
    const expandGrid = (tempGrid, coord, isOddRowOffset) => {
        var tempIsOddRowOffset = isOddRowOffset
        var row = coord[0]
        var col = coord[1]
        //activate the clicked node
        tempGrid[row][col].isBufferHex = false


        //If the first col is clicked, add col at the start of row arrays
        if (col === 0) {
            //For all the rows move add one col at the start
            for (var i = 0; i < tempGrid.length; i++) {
                tempGrid[i].unshift("")
            }
            //the clicked Hex is now situated 1 col further
            col = (col === '' ? 1 : col + 1)
        }
        //if the first row is clicked, add a new empty row as the starting row
        if (row === 0) {
            const newRow = new Array(tempGrid[0].length)
            tempGrid.unshift(newRow)
            //the clicked Hex is now situated 1 row down
            tempIsOddRowOffset = !tempIsOddRowOffset
            row += 1

        }
        if (col === (tempGrid[0].length - 1)) {
            for (var i = 0; i < tempGrid.length; i++) {
                tempGrid[i].push('')
            }
        }
        if (row === (tempGrid.length - 1)) {
            tempGrid.push(new Array(tempGrid[0].length))
        }



        //Add nodes around clicked node
        if ((((row % 2) !== 0) && !tempIsOddRowOffset) || (((row % 2) === 0) && tempIsOddRowOffset)) {
            if (!tempGrid[row - 1][col]) { tempGrid[row - 1][col] = new Node() }
            if (!tempGrid[row - 1][col + 1]) { tempGrid[row - 1][col + 1] = new Node() }

            if (!tempGrid[row][col - 1]) { tempGrid[row][col - 1] = new Node() }
            if (!tempGrid[row][col + 1]) { tempGrid[row][col + 1] = new Node() }

            if (!tempGrid[row + 1][col]) { tempGrid[row + 1][col] = new Node() }
            if (!tempGrid[row + 1][col + 1]) { tempGrid[row + 1][col + 1] = new Node() }
        }


        if ((((row % 2) == 0) && !tempIsOddRowOffset) || (((row % 2) !== 0) && tempIsOddRowOffset)) {
            if (!tempGrid[row - 1][col - 1]) { tempGrid[row - 1][col - 1] = new Node() }
            if (!tempGrid[row - 1][col]) { tempGrid[row - 1][col] = new Node() }

            if (!tempGrid[row][col - 1]) { tempGrid[row][col - 1] = new Node() }
            if (!tempGrid[row][col + 1]) { tempGrid[row][col + 1] = new Node() }

            if (!tempGrid[row + 1][col - 1]) { tempGrid[row + 1][col - 1] = new Node() }
            if (!tempGrid[row + 1][col]) { tempGrid[row + 1][col] = new Node() }
        }
        return { tempGrid, tempIsOddRowOffset }
    }
    const removeUnconnectedNodes = (tempGrid, tempIsOddRowOffset) => {

        for (var i = 0; i < tempGrid.length; i++) {
            for (var j = 0; j < tempGrid[0].length; j++) {
                //if its an empty node, make sure its connected to a node with content, if not delete node
                if (tempGrid[i][j] && tempGrid[i][j].isBufferHex) {
                    var isConnectedToBug = false
                    //check the same row
                    if (j > 0 && tempGrid[i][j - 1] && !tempGrid[i][j - 1].isBufferHex) { isConnectedToBug = true }
                    if (j < (tempGrid[0].length - 1) && tempGrid[i][j + 1] && !tempGrid[i][j + 1].isBufferHex) { isConnectedToBug = true }
                    //check top and bot row
                    if (((i % 2) !== 0 && tempIsOddRowOffset) || ((i % 2) === 0 && !tempIsOddRowOffset)) {
                        if (i > 0) {
                            if (tempGrid[i - 1][j] && !tempGrid[i - 1][j].isBufferHex) { isConnectedToBug = true }
                            if (j > 0 && tempGrid[i - 1][j - 1] && !tempGrid[i - 1][j - 1].isBufferHex) { isConnectedToBug = true }
                        }
                        if (i < (tempGrid.length - 1)) {
                            if (tempGrid[i + 1][j] && !tempGrid[i + 1][j].isBufferHex) { isConnectedToBug = true }
                            if (j > 0 && tempGrid[i + 1][j - 1] && !tempGrid[i + 1][j - 1].isBufferHex) { isConnectedToBug = true }
                        }
                    }
                    if (((i % 2) !== 0 && !tempIsOddRowOffset) || ((i % 2) === 0 && tempIsOddRowOffset)) {
                        if (i > 0) {
                            if (tempGrid[i - 1][j] && !tempGrid[i - 1][j].isBufferHex) { isConnectedToBug = true }
                            if (j < (tempGrid[0].length - 1) && tempGrid[i - 1][j + 1] && !tempGrid[i - 1][j + 1].isBufferHex) { isConnectedToBug = true }
                        }
                        if (i < (tempGrid.length - 1)) {
                            if (tempGrid[i + 1][j] && !tempGrid[i + 1][j].isBufferHex) { isConnectedToBug = true }
                            if (j < (tempGrid[0].length - 1) && tempGrid[i + 1][j + 1] && !tempGrid[i + 1][j + 1].isBufferHex) { isConnectedToBug = true }
                        }
                    }
                    if (!isConnectedToBug) { tempGrid[i][j] = '' }
                }
            }
        }
        return tempGrid
    }
    const keepGridSmall = (grid, tempIsOddRowOffset) => {

        var tempGrid = grid
        //check for empty borders
        //Check if top row empty,if empty remove first row
        var isEmpty = true
        for (var i = 0; i < tempGrid[0].length; i++) { if (tempGrid[0][i]) { isEmpty = false } }
        if (isEmpty) {

            tempIsOddRowOffset = !tempIsOddRowOffset
            tempGrid.shift()
        }
        isEmpty = true
        //check if left col empty, if empty, remove first elem of each row
        for (var i = 0; i < tempGrid.length; i++) { if (tempGrid[i][0]) { isEmpty = false } }
        if (isEmpty) {
            for (var i = 0; i < tempGrid.length; i++) { tempGrid[i].shift() }
        }
        isEmpty = true
        //check if bot row empty, if empty remove last row
        for (var i = 0; i < tempGrid[0].length; i++) { if (tempGrid[tempGrid.length - 1][i]) { isEmpty = false } }
        if (isEmpty) { tempGrid.pop() }
        isEmpty = true
        //check if right col empty,if empty remove the last elem of each row
        for (var i = 0; i < tempGrid.length; i++) { if (tempGrid[i][tempGrid[0].length - 1]) { isEmpty = false } }
        if (isEmpty) {
            for (var i = 0; i < tempGrid.length; i++) { tempGrid[i].pop() }
        }
        return { tempGrid, tempIsOddRowOffset }

    }

    //Move a bug already in play
    const move_bug = (tempGrid, startNodeCoord, endNodeCoord, isOddRowOffset) => {
        tempGrid[endNodeCoord[0]][endNodeCoord[1]].content.unshift(tempGrid[startNodeCoord[0]][startNodeCoord[1]].content.shift())

        if (!tempGrid[startNodeCoord[0]][startNodeCoord[1]].content[0]) {
            tempGrid[startNodeCoord[0]][startNodeCoord[1]].isBufferHex = true
        }

        return gridMaintenance(tempGrid, endNodeCoord, isOddRowOffset)


    }
    //Place a bug from the player's hand
    const place_bug = (tempGrid, nodeCoordFromHand, endNodeCoord, player, isOddRowOffset) => {
        //If theres stil a bug left in the selected node, remove it and place it in the enbdNodeCoord
        if (player.hand[nodeCoordFromHand[1]].content[0]) {
            tempGrid[endNodeCoord[0]][endNodeCoord[1]].content.unshift(player.hand[nodeCoordFromHand[1]].content.shift())
            var { gridToReturn, tempIsOddRowOffset } = gridMaintenance(tempGrid, endNodeCoord, isOddRowOffset)
        }
        return { gridToReturn, tempIsOddRowOffset, player }
    }
